// Global variables for animation state
const canvas = document.getElementById('scheduler-canvas');
const ctx = canvas.getContext('2d');
let animationFrameId = null; // Stores the requestAnimationFrame ID for smooth animation
let currentTraceStep = 0;    // Tracks the current time unit (t)
let animationSpeed = 500;    // Initial speed in milliseconds (matches index.html default)

// --- Initialization and Control Functions ---

/**
 * Initializes the animation and sets up the canvas dimensions.
 * This is called once from algorithm.js after the trace is generated.
 * @param {Array} trace - The execution timeline generated by FCFS logic.
 */
function initAnimation(trace) {
    if (trace.length === 0) return;
    
    // Clear the canvas and reset the step
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    currentTraceStep = 0;
    
    // Set event listeners for control buttons
    document.getElementById('play-btn').onclick = startAnimation;
    document.getElementById('pause-btn').onclick = pauseAnimation;
    document.getElementById('step-forward-btn').onclick = () => stepAnimation(1);
    document.getElementById('step-backward-btn').onclick = () => stepAnimation(-1);
    document.getElementById('speed').onchange = (e) => { 
        animationSpeed = parseInt(e.target.value); 
    };

    // Draw the initial state (t=0)
    renderFrame(trace[currentTraceStep]);
}

/** Starts the continuous animation loop. */
function startAnimation() {
    if (animationFrameId) return; // Already running

    document.getElementById('play-btn').disabled = true;
    document.getElementById('pause-btn').disabled = false;

    animateLoop();
}

/** Pauses the continuous animation loop. */
function pauseAnimation() {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;

    document.getElementById('play-btn').disabled = false;
    document.getElementById('pause-btn').disabled = true;
}

/** Advances or rewinds the animation by one step. */
function stepAnimation(direction) {
    pauseAnimation(); // Always pause before manual step

    const newStep = currentTraceStep + direction;

    if (newStep >= 0 && newStep < executionTrace.length) {
        currentTraceStep = newStep;
        renderFrame(executionTrace[currentTraceStep]);
    }
}

/** Main loop for continuous animation (uses requestAnimationFrame for smoothness) */
function animateLoop() {
    if (currentTraceStep >= executionTrace.length) {
        pauseAnimation();
        return;
    }

    renderFrame(executionTrace[currentTraceStep]);
    currentTraceStep++;
    
    // Use a timeout to control the speed (ms/step)
    setTimeout(() => {
        animationFrameId = requestAnimationFrame(animateLoop);
    }, 1000 - animationSpeed); // Convert slider value to delay time
}


// --- Rendering Functions (Canvas API) ---

/** Gets a color for a process ID (for consistent color coding) */
function getProcessColor(pid) {
    // Simple hash to assign a unique color per process
    const hash = pid.charCodeAt(1) * 10 + pid.charCodeAt(2) * 5;
    const colors = ['#4CAF50', '#2196F3', '#FFC107', '#E91E63', '#9C27B0'];
    return colors[hash % colors.length];
}

/** Renders all elements for the current time step (frame-by-frame transition) */
function renderFrame(state) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const maxTime = executionTrace.length - 1;

    // 1. Draw Gantt Chart up to the current time (t)
    renderGanttChart(state.time);

    // 2. Draw Time Scale
    renderTimeScale(maxTime);
    
    // 3. Update Status Panels
    updateStatsPanel(state);
    updateProcessStates(state);

    // Update control button disabled state
    document.getElementById('step-backward-btn').disabled = state.time === 0;
    document.getElementById('step-forward-btn').disabled = state.time === maxTime;
}

/** Draws the Gantt Chart showing execution up to the current time step. */
function renderGanttChart(currentTime) {
    const barHeight = 60;
    const yStart = 40;
    const timeUnitWidth = canvas.width / (executionTrace.length - 1); // Width per time unit

    let lastFinishTime = 0;
    
    calculatedProcesses.forEach(p => {
        // Only draw the part of the process that has finished by the currentTime
        const actualStart = p.start;
        const actualFinish = Math.min(p.finish, currentTime);
        
        if (actualFinish > actualStart) {
            const xStart = actualStart * timeUnitWidth;
            const width = (actualFinish - actualStart) * timeUnitWidth;
            
            // Draw the bar
            ctx.fillStyle = getProcessColor(p.id);
            ctx.fillRect(xStart, yStart, width, barHeight);
            
            // Draw the process ID text
            ctx.fillStyle = '#FFFFFF'; // White text
            ctx.font = '14px Arial';
            ctx.fillText(p.id, xStart + 5, yStart + barHeight / 2 + 5);
        }

        // Draw the current time pointer
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(currentTime * timeUnitWidth, 20);
        ctx.lineTo(currentTime * timeUnitWidth - 5, 10);
        ctx.lineTo(currentTime * timeUnitWidth + 5, 10);
        ctx.closePath();
        ctx.fill();
        ctx.fillText(`t=${currentTime}`, currentTime * timeUnitWidth - 15, 35);
    });
}

/** Draws the time axis below the chart. */
function renderTimeScale(maxTime) {
    const yAxis = 110;
    const timeUnitWidth = canvas.width / maxTime;

    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(0, yAxis);
    ctx.lineTo(canvas.width, yAxis);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    
    // Draw markers for every time unit
    for (let t = 0; t <= maxTime; t++) {
        const x = t * timeUnitWidth;
        // Draw vertical tick mark
        ctx.beginPath();
        ctx.moveTo(x, yAxis);
        ctx.lineTo(x, yAxis + 5);
        ctx.stroke();
        
        // Draw time number
        ctx.fillText(t, x - 5, yAxis + 20);
    }
}


// --- Status Panel Updates ---

/** Updates the Ready Queue and Completed Process lists (Real-time visualization) */
function updateProcessStates(state) {
    const readyQueueDiv = document.getElementById('ready-queue-display');
    const statsDiv = document.getElementById('statistics');

    // Update Ready Queue
    readyQueueDiv.innerHTML = state.readyQueue.map(pid => 
        `<span style="background-color: #FFC107; padding: 2px 5px; margin-right: 5px; border-radius: 3px;">${pid}</span>`
    ).join('');

    // Update Running Process status
    if (state.runningProcess) {
        statsDiv.querySelector('h3').textContent = `Running: ${state.runningProcess}`;
    } else if (state.time === executionTrace.length - 1) {
        statsDiv.querySelector('h3').textContent = 'Simulation Complete';
    } else {
        statsDiv.querySelector('h3').textContent = 'CPU Idle / Transition';
    }
}

/** Updates the execution statistics panel. */
function updateStatsPanel(state) {
    let totalWaitingTime = 0;
    let totalTurnaroundTime = 0;
    let completedCount = 0;

    // Calculate averages based only on processes that have completed up to this step
    calculatedProcesses.forEach(p => {
        if (p.finish <= state.time) {
            totalWaitingTime += p.waiting;
            totalTurnaroundTime += p.turnaround;
            completedCount++;
        }
    });

    const avgWaiting = completedCount > 0 ? (totalWaitingTime / completedCount).toFixed(2) : 'N/A';
    const avgTurnaround = completedCount > 0 ? (totalTurnaroundTime / completedCount).toFixed(2) : 'N/A';

    document.getElementById('current-time').textContent = state.time;
    document.getElementById('avg-waiting-time').textContent = avgWaiting;
    document.getElementById('avg-turnaround-time').textContent = avgTurnaround;
}

// Placeholder for Export Functionality (Required Deliverable)
function exportScreenshot() {
    // This function can be implemented using the canvas.toDataURL() method
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = 'fcfs_trace.png';
    link.href = dataURL;
    link.click();
    console.log('Screenshot exported.');
}