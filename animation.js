// --- Global Data Structures (Assumed to be defined in algorithm.js, or accessible globally) ---
// Variables for Canvas API
const canvas = document.getElementById('scheduler-canvas');
const ctx = canvas.getContext('2d');

// Animation control variables
let animationFrameId = null; // Stores the requestAnimationFrame ID
let currentTraceStep = 0;    // Tracks the current time unit (t)
let animationSpeed = 500;    // Initial speed in milliseconds (ms/step delay)

// Assumed to be populated by algorithm.js
// let executionTrace = [];
// let calculatedProcesses = []; 
// let processCounter is now defined here
let processCounter = 4; // Start counter based on initial rows (P1, P2, P3 are 3, so next is P4)


// --- Initialization and Control Functions ---

/**
 * Initializes the animation. Called once from algorithm.js after the trace is generated.
 * @param {Array} trace - The execution timeline generated by FCFS logic.
 */
function initAnimation(trace) {
    if (trace.length === 0) return;
    
    // Clear the canvas and reset the step
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    currentTraceStep = 0;
    
    // Set event listeners for control buttons
    document.getElementById('play-btn').onclick = startAnimation;
    document.getElementById('pause-btn').onclick = pauseAnimation;
    document.getElementById('step-forward-btn').onclick = () => stepAnimation(1);
    document.getElementById('step-backward-btn').onclick = () => stepAnimation(-1);
    document.getElementById('speed').onchange = (e) => { 
        animationSpeed = parseInt(e.target.value); 
    };

    // Draw the initial state (t=0)
    renderFrame(executionTrace[currentTraceStep]);
}

/** Starts the continuous animation loop. */
function startAnimation() {
    if (animationFrameId) return; // Already running

    document.getElementById('play-btn').disabled = true;
    document.getElementById('pause-btn').disabled = false;

    animateLoop();
}

/** Pauses the continuous animation loop. */
function pauseAnimation() {
    clearTimeout(animationFrameId);
    animationFrameId = null;

    document.getElementById('play-btn').disabled = false;
    document.getElementById('pause-btn').disabled = true;
}

/** Advances or rewinds the animation by one step. */
function stepAnimation(direction) {
    pauseAnimation(); // Always pause before manual step

    const newStep = currentTraceStep + direction;

    if (newStep >= 0 && newStep < executionTrace.length) {
        currentTraceStep = newStep;
        renderFrame(executionTrace[currentTraceStep]);
    }
}

/** Main loop for continuous animation (uses setTimeout for time control) */
function animateLoop() {
    if (currentTraceStep >= executionTrace.length) {
        pauseAnimation();
        return;
    }

    renderFrame(executionTrace[currentTraceStep]);
    currentTraceStep++;
    
    setTimeout(() => {
        animateLoop();
    }, 1000 - animationSpeed); 
}


// --- Rendering Functions (Canvas API) ---

/** Gets a unique and consistent color for a process ID (for color coding) */
function getProcessColor(pid) {
    let sum = 0;
    for (let i = 0; i < pid.length; i++) {
        sum += pid.charCodeAt(i);
    }
    const colors = ['#4CAF50', '#2196F3', '#FFC107', '#E91E63', '#9C27B0', '#00BCD4', '#8BC34A'];
    return colors[sum % colors.length];
}

/** Renders all elements for the current time step (frame-by-frame transition) */
function renderFrame(state) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const maxTime = executionTrace.length > 0 ? executionTrace.length - 1 : 0;

    renderGanttChart(state.time);
    renderTimeScale(maxTime);
    updateStatsPanel(state);
    updateProcessStates(state);

    document.getElementById('step-backward-btn').disabled = state.time === 0;
    document.getElementById('step-forward-btn').disabled = state.time === maxTime;
}

/** Draws the Gantt Chart showing execution up to the current time step. */
function renderGanttChart(currentTime) {
    const barHeight = 60;
    const yStart = 40;
    const maxTime = executionTrace.length > 0 ? executionTrace.length - 1 : 10; // Prevent division by zero
    const timeUnitWidth = canvas.width / maxTime;

    calculatedProcesses.forEach(p => {
        const actualStart = p.start;
        const actualFinish = Math.min(p.finish, currentTime);
        
        if (actualFinish > actualStart) {
            const xStart = actualStart * timeUnitWidth;
            const width = (actualFinish - actualStart) * timeUnitWidth;
            
            ctx.fillStyle = getProcessColor(p.id);
            ctx.fillRect(xStart, yStart, width, barHeight);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '14px Arial';
            ctx.fillText(p.id, xStart + 5, yStart + barHeight / 2 + 5);
        }
    });

    // Draw the current time pointer (red marker)
    ctx.fillStyle = 'red';
    const markerX = currentTime * timeUnitWidth;
    
    ctx.beginPath();
    ctx.moveTo(markerX, 20);
    ctx.lineTo(markerX - 5, 10);
    ctx.lineTo(markerX + 5, 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillText(`t=${currentTime}`, markerX - 15, 35);
}

/** Draws the time axis below the Gantt chart. */
function renderTimeScale(maxTime) {
    const yAxis = 110;
    const timeUnitWidth = canvas.width / maxTime;

    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(0, yAxis);
    ctx.lineTo(canvas.width, yAxis);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    
    for (let t = 0; t <= maxTime; t++) {
        const x = t * timeUnitWidth;
        ctx.beginPath();
        ctx.moveTo(x, yAxis);
        ctx.lineTo(x, yAxis + 5);
        ctx.stroke();
        ctx.fillText(t, x - 5, yAxis + 20);
    }
}

/** Updates the Ready Queue and Completed Process lists (Real-time visualization) */
function updateProcessStates(state) {
    const readyQueueDiv = document.getElementById('ready-queue-display');
    const statsDiv = document.getElementById('statistics');

    readyQueueDiv.innerHTML = state.readyQueue.map(pid => 
        `<span style="background-color: #FFC107; color: #333; padding: 4px 8px; margin-right: 5px; border-radius: 3px; font-weight: bold;">${pid}</span>`
    ).join('');

    if (state.runningProcess) {
        statsDiv.querySelector('h3').textContent = `Running: ${state.runningProcess}`;
        statsDiv.style.borderLeftColor = '#4CAF50';
    } else if (state.time === executionTrace.length - 1 && state.completedProcesses.length === calculatedProcesses.length) {
        statsDiv.querySelector('h3').textContent = 'Simulation Complete';
        statsDiv.style.borderLeftColor = '#333';
    } else {
        statsDiv.querySelector('h3').textContent = 'CPU Idle / Transition';
        statsDiv.style.borderLeftColor = '#ccc';
    }
}

/** Updates the execution statistics panel. */
function updateStatsPanel(state) {
    let totalWaitingTime = 0;
    let totalTurnaroundTime = 0;
    let completedCount = 0;

    calculatedProcesses.forEach(p => {
        if (p.finish <= state.time) {
            totalWaitingTime += p.waiting;
            totalTurnaroundTime += p.turnaround;
            completedCount++;
        }
    });

    const avgWaiting = completedCount > 0 ? (totalWaitingTime / completedCount).toFixed(2) : 'N/A';
    const avgTurnaround = completedCount > 0 ? (totalTurnaroundTime / completedCount).toFixed(2) : 'N/A';

    document.getElementById('current-time').textContent = state.time;
    document.getElementById('avg-waiting-time').textContent = avgWaiting;
    document.getElementById('avg-turnaround-time').textContent = avgTurnaround;
}

/** Functionality for Export Screenshot (Required Deliverable) */
function exportScreenshot() {
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = 'fcfs_trace_t' + currentTraceStep + '.png';
    link.href = dataURL;
    link.click();
}


// --- Process Management Helper Functions (Now in animation.js) ---

/** Adds a new process row to the input table. */
function addProcessRow() {
    const tableBody = document.getElementById('process-table').getElementsByTagName('tbody')[0];
    const newRow = tableBody.insertRow();
    const pid = `P${processCounter++}`;

    // Insert cells with inputs
    newRow.insertCell(0).textContent = pid;
    newRow.insertCell(1).innerHTML = `<input type="number" value="0" min="0" data-id="${pid}" data-field="arrival">`;
    newRow.insertCell(2).innerHTML = `<input type="number" value="1" min="1" data-id="${pid}" data-field="burst">`;
    
    // Add the new DELETE button cell
    newRow.insertCell(3).innerHTML = `<button onclick="deleteProcess(this)">Delete</button>`; 
}

/** Deletes a process row from the input table and relabels processes. */
function deleteProcess(btn) {
    // Get the parent row (TR) of the button
    const row = btn.parentNode.parentNode;
    row.parentNode.removeChild(row);
    
    // Re-label the process IDs after deletion
    relabelProcesses();
}

/** Re-labels the Process IDs (P1, P2, P3...) sequentially after a deletion. */
function relabelProcesses() {
    const tableBody = document.getElementById('process-table').getElementsByTagName('tbody')[0];
    const rows = tableBody.rows;
    let counter = 1;
    for (const row of rows) {
        row.cells[0].textContent = `P${counter++}`;
    }
    processCounter = counter;
}